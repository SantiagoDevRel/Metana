// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

//~~~~~~~~ import Libraries ~~~~~~~~ 
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";

//~~~~~~~~ import Contracts ~~~~~~~~
import "./UpgradeableNFT.sol";
import "./UpgradeableERC20.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";


contract UpStaking is Initializable, UUPSUpgradeable, OwnableUpgradeable, IERC721ReceiverUpgradeable, ReentrancyGuardUpgradeable{
    
    //~~~~~~~~ Libraries ~~~~~~~~ 
    using AddressUpgradeable for address;

    //~~~~~~~~ Events ~~~~~~~~ 
    event NFTStaked(address from, uint256 tokenId);
    event RewardsClaimed(address to, uint256 amount);
    event NFTWithdrawn(address to, uint256 tokenId);
    event UpdatedRewards(uint256 oldRewards, uint256 newRewards);

    //~~~~~~~~ State variables ~~~~~~~~ 
    UpNFT private s_nft;
    UpERC20 private s_token;
    uint256 private s_rewardsTokenPerSecond;
    
    //mapping  User --> NFT id --> bool (check if the user has staked or not that NFT)
    mapping(address => mapping(uint => bool)) private s_userToNFTStaked;

    //mapping User --> NFT id --> block.timestamp (check at what time the NFT was staked)
    mapping(address => mapping(uint => uint)) private s_timeNFTStakedByUser;

    //mapping User --> NFT id --> rewards (check the rewards generated by each NFT, allowing users to stake various NFTs)
    mapping(address => mapping(uint => uint)) private s_balanceOfRewardsPerNFT;

    function init(UpERC20 _token,UpNFT _nft) external initializer(){
        s_nft = _nft;        
        s_token = _token;
        s_rewardsTokenPerSecond = 11574074;
        __Ownable_init();
        __ReentrancyGuard_init();
    }

    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner{
        require(newImplementation.isContract(), "UpERC20: New implementation is not a contract");
    }

    //~~~~~~~~ Public/External functions ~~~~~~~~ 
    /*
        * Function to stake the NFT into this contract
        * User MUST approve before
        * this contract will call safeTransferFrom() to send the NFT to this contract
        * set mapping User --> NFT id --> true (staked)
        * set mapping User --> NFT id --> block.timestamp (time where the NFT is staked)
    */
    function stakeNFT(uint _tokenId) external virtual {
        address _sender = msg.sender;
        s_nft.safeTransferFrom(_sender, address(this), _tokenId);
        s_userToNFTStaked[_sender][_tokenId] = true;
        s_timeNFTStakedByUser[_sender][_tokenId] = block.timestamp;
        emit NFTStaked(_sender, _tokenId);
    }

    /*
        * Function to claim the rewards:
        * check if user can withdraw rewards and call that function to generate the rewards for the user
        * if the user pass the require(), then call the contract MrToken and the rewards for the user
        * send the rewards (ERC20) to the user
        * set mapping User --> NFT id --> 0 rewards
    */
    function claimRewards(uint _tokenId) public virtual nonReentrant(){
        address _sender = msg.sender;
        require(s_userToNFTStaked[_sender][_tokenId], "MrStakingv2: You don't have any NFT staked");
        require(_userCanWithdrawRewards(_tokenId), "MrStakingv2: The 24h have not passed yet, try later.");
        uint256 _rewardsToClaim = s_balanceOfRewardsPerNFT[_sender][_tokenId];
        require(_rewardsToClaim > 0,"MrStakingv2: You have nothing to claim");
        s_balanceOfRewardsPerNFT[_sender][_tokenId] = 0;
        s_timeNFTStakedByUser[_sender][_tokenId] = block.timestamp;
        s_token.mint(_sender, _rewardsToClaim);
        emit RewardsClaimed(_sender,_rewardsToClaim);
    }

    /*
        * Function to Withdraw NFT:
        * check the mapping to see if the user has staked the NFT with that tokenID
        * send the NFT back to the user using safeTransferFrom()
        * set mapping User --> NFT id --> false (not staked anymore)
    */
    function withdrawNFT(uint _tokenId) external virtual nonReentrant() {
        address _sender = msg.sender;
        require(s_userToNFTStaked[_sender][_tokenId], "MrStakingv2: You are not allowed to withdraw this token");
        claimRewards(_tokenId);
        s_nft.safeTransferFrom(address(this), _sender, _tokenId);
        s_userToNFTStaked[_sender][_tokenId] = false;
        emit NFTWithdrawn(_sender, _tokenId);
    }

    function updateRewards(uint256 _newRewardsPerSecond) external virtual onlyOwner{
        uint256 _oldRewards = s_rewardsTokenPerSecond; 
        s_rewardsTokenPerSecond = _newRewardsPerSecond;
        emit UpdatedRewards(_oldRewards, _newRewardsPerSecond);
    }

 

    //Function required to receive ERC721 tokens
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external override pure returns (bytes4){
        return IERC721ReceiverUpgradeable.onERC721Received.selector;
    }

    //~~~~~~~~ Internal functions ~~~~~~~~ 

    /*
        * Function to check if user can withdraw -(only called from withdrawNFT function)
        * find the difference between the time the user staked the NFT and the current time in seoncds
        * if the user has staked for more than 1 minute (should be 24 hours), it will generate the rewards for the user
        * return true
    */
    function _userCanWithdrawRewards(uint _tokenId) internal virtual returns(bool){
        uint timeStaked = (s_timeNFTStakedByUser[msg.sender][_tokenId]);
        uint256 _currentTime = block.timestamp;
        if( timeStaked + 1 minutes < _currentTime){
            _generateRewards(_currentTime-timeStaked, _tokenId);
            return true;
        }
        return false;
    }

    /*
        * Function to generate the rewards - (only called from withdrawNFT function)
        * the user will get rewarded with 10 tokens x 24h || 0.00011574074 tokens x second == 11574074 tokens x second
        * set the time staked by the 
    */
    function _generateRewards(uint timeInSeconds, uint _tokenId) internal virtual {
        uint reward = timeInSeconds * s_rewardsTokenPerSecond;
        s_balanceOfRewardsPerNFT[msg.sender][_tokenId] += reward;
    }


    

}