// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

//~~~~~~~~ import Libraries ~~~~~~~~ 
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";

//~~~~~~~~ import Contracts ~~~~~~~~
import "./UpgradeableNFT.sol";
import "./UpgradeableERC20.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";


contract UpStaking is Initializable, UUPSUpgradeable, OwnableUpgradeable, IERC721ReceiverUpgradeable, ReentrancyGuardUpgradeable{
    
    //~~~~~~~~ Libraries ~~~~~~~~ 
    using AddressUpgradeable for address;

    //~~~~~~~~ State variables ~~~~~~~~ 
    UpNFT private nft;
    UpERC20 private token;
    uint256 private rewardsTokenPerSecond;
    
    //mapping  User --> NFT id --> bool (check if the user has staked or not that NFT)
    mapping(address => mapping(uint => bool)) private userToNFTStaked;

    //mapping User --> NFT id --> block.timestamp (check at what time the NFT was staked)
    mapping(address => mapping(uint => uint)) private timeNFTStakedByUser;

    //mapping User --> NFT id --> rewards (check the rewards generated by each NFT, allowing users to stake various NFTs)
    mapping(address => mapping(uint => uint)) private balanceOfRewardsPerNFT;

    function init(UpERC20 _token,UpNFT _nft) external initializer(){
        nft = _nft;        
        token = _token;
        rewardsTokenPerSecond = 11574074;
        __Ownable_init();
        __ReentrancyGuard_init();
    }

    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner{
        require(newImplementation.isContract(), "UpERC20: New implementation is not a contract");
    }

    //~~~~~~~~ Public/External functions ~~~~~~~~ 
    /*
        * Function to stake the NFT into this contract
        * User MUST approve before
        * this contract will call safeTransferFrom() to send the NFT to this contract
        * set mapping User --> NFT id --> true (staked)
        * set mapping User --> NFT id --> block.timestamp (time where the NFT is staked)
    */
    function stakeNFT(uint _tokenId) external {
        address _sender = msg.sender;
        nft.safeTransferFrom(_sender, address(this), _tokenId);
        userToNFTStaked[_sender][_tokenId] = true;
        timeNFTStakedByUser[_sender][_tokenId] = block.timestamp;
    }

    /*
        * Function to claim the rewards:
        * check if user can withdraw rewards and call that function to generate the rewards for the user
        * if the user pass the require(), then call the contract MrToken and the rewards for the user
        * send the rewards (ERC20) to the user
        * set mapping User --> NFT id --> 0 rewards
    */
    function claimRewards(uint _tokenId) public nonReentrant(){
        address _sender = msg.sender;
        require(userToNFTStaked[_sender][_tokenId], "MrStakingv2: You don't have any NFT staked");
        require(_userCanWithdrawRewards(_tokenId), "MrStakingv2: The 24h have not passed yet, try later.");
        uint256 _rewardsToClaim = balanceOfRewardsPerNFT[_sender][_tokenId];
        require(_rewardsToClaim > 0,"MrStakingv2: You have nothing to claim");
        balanceOfRewardsPerNFT[_sender][_tokenId] = 0;
        timeNFTStakedByUser[_sender][_tokenId] = block.timestamp;
        token.mint(_sender, _rewardsToClaim);
    }

    /*
        * Function to Withdraw NFT:
        * check the mapping to see if the user has staked the NFT with that tokenID
        * send the NFT back to the user using safeTransferFrom()
        * set mapping User --> NFT id --> false (not staked anymore)
    */
    function witdrawNFT(uint _tokenId) external nonReentrant() {
        address _sender = msg.sender;
        require(userToNFTStaked[_sender][_tokenId], "MrStakingv2: You are not allowed to withdraw this token");
        claimRewards(_tokenId);
        nft.safeTransferFrom(address(this), _sender, _tokenId);
        userToNFTStaked[_sender][_tokenId] = false;
    }

    function updateRewards(uint256 _newRewardsPerSecond) external onlyOwner{
        rewardsTokenPerSecond = _newRewardsPerSecond;
    }

 

    //Function required to receive ERC721 tokens
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external override pure returns (bytes4){
        return IERC721ReceiverUpgradeable.onERC721Received.selector;
    }

    //~~~~~~~~ Internal functions ~~~~~~~~ 

    /*
        * Function to check if user can withdraw -(only called from withdrawNFT function)
        * find the difference between the time the user staked the NFT and the current time in seoncds
        * if the user has staked for more than 1 minute (should be 24 hours), it will generate the rewards for the user
        * return true
    */
    function _userCanWithdrawRewards(uint _tokenId) internal returns(bool){
        uint timeStaked = (timeNFTStakedByUser[msg.sender][_tokenId]);
        uint256 _currentTime = block.timestamp;
        if( timeStaked + 1 minutes < _currentTime){
            _generateRewards(_currentTime-timeStaked, _tokenId);
            return true;
        }
        return false;
    }

    /*
        * Function to generate the rewards - (only called from withdrawNFT function)
        * the user will get rewarded with 10 tokens x 24h || 0.00011574074 tokens x second == 11574074 tokens x second
        * set the time staked by the 
    */
    function _generateRewards(uint timeInSeconds, uint _tokenId) internal {
        uint reward = timeInSeconds * rewardsTokenPerSecond;
        balanceOfRewardsPerNFT[msg.sender][_tokenId] += reward;
    }


    

}